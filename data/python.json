{
    "Heading1" : "Python",
    "Contents" :
    [
        {
            "Subtitle" : "Basics",
            "Intro" : "Start",
            "Cheats" : [
                {
                    "Explanation" : "Execute when called but not when imported",
                    "Cheat" : "if __name__ == '__main__':\n\tmain()",
                    "Class" : "language-python"
                }
            ]
        },
        {
            "Subtitle" : "Selenium",
            "Intro" : "Some snippets for selenium.",
            "Cheats" : [
                {
                    "Explanation" : "Open Chrome with specified download folder.",
                    "Cheat" : "from selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom webdriver_manager.chrome import ChromeDriverManager\n\noptions = webdriver.ChromeOptions()\noptions.add_experimental_option('prefs', {'download.default_directory' : '\\data\\downloads'})\ndriver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)",
                    "Class" : "language-python"
                }
            ]
        },
        {
            "Subtitle" : "Selenium & Race conditions",
            "Intro" : "What a race condition is?\n\nIn short a race condition is a situation where a process B is started even though a process A was not ready or it is multithreaded or for some other reason a process B is started too early. In turn starting B too early results in unexpected behavior if error handling does not catch it.\n\nSo how could this ever happen with web scraping? Well, basically A is the web app being scraped while B is the scraper. Ideally A should be done before B. Selenium continues if the html status is ready, but the status may be ready even though the app may still be executing some queries that would append new web elements to the html. Selenium does not automatically see or detect if the app is still processing some dynamic processes, thus B may start too early.\n\nFrom scraping point of view, user friendly or accessibility compliant apps are may be easier, as they should inform the user or their readers about these things. Furthermore the app may still declare the completion of the dynamic process of the web app in a way that could be detected using javascript shenanigans with selenium, but that may take more time and effort than what it may be worth only to find out later, that they changed it.\n\nThe easiest way to better overcome race conditions is to introduce WebDriverWait as that gives the web app some time to load the searched web element. However, WebDriverWait is not perfect in all cases, which then may lead to web scraping process being carried out too early. Additional waiting, looping and check ups may further improve handling race conditions - keeping in mind that nothing is ever bulletproof.\n\n"
        },
        {
            "Subtitle" : "Switching browser tabs",
            "Intro" : "",
            "Cheats" : [
                {
                    "Explanation" : "Depending on the web app and how a new tab is opened and what it contains, it is possible for the new tab to open so slowly that it is not yet open when selenium would determine html to be ready to continue executing python code. If the new tab contains similar web elements than the previous, it could be possible to actually continue in the previous tab as if it was the new, expected tab. Depending on the situation this could create issues down the line if the opening of the new tab is no way verified within the code itself.",
                    "Cheat" : "driver.get(\"https://bittikatti.github.io/cheat_sheet/\")\n\ncurrent_windows = driver.window_handles\n\n# Open the first link in a new tab:\nhref = WebDriverWait(driver, 30).until(\n    EC.visibility_of_element_located((By.XPATH, \"//a\"))\n).get_attribute(\"href\")\ndriver.execute_script(\"window.open('%s', '_blank')\" % href)\n\n# Wait for the window to open\n# Other option is EC.number_of_windows_to_be\nopened = WebDriverWait(driver, 5).until(EC.new_window_is_opened(current_windows))\nif not opened:\n    raise Exception(\"The new window was not opened\")\n\ndriver.switch_to.new_window(\"tab\")",
                    "Class" : "language-python"
                }
            ]
        },
        {
            "Subtitle" : "Multiple dynamically populated web elements",
            "Intro" : "",
            "Cheats" : [
                {
                    "Explanation" : "In case it is necessary to look for multiple web elements, there is a possibility that not all web elements are loaded at the same time.\n\nThe most obvious cause would be that the site needs to be scrolled down to even load more web elements. But even when that is not the issue, this may be: If the site fetches and loads the queried data asynchronously, all of the data may not returned and loaded at the same millisecond.",
                    "Cheat" : "def wait_for_multiple(by: By, xpath:str, interval_sleep:int = 7, max_wait_time:int = 120) -> list[WebElement]:\n    \"\"\"Look for multiple web elements\n    Check if more web elements appears after given time. If no more appeared, assumed that all were loaded.\n\n    Arguments:\n        by: By.(type)\n        xpath\n        interval_sleep: how long to wait before checking if new elements appeared\n        max_wait_time: how long to wait if more elements keep appearing at each check\n    Return:\n        list of found web elements\n    \n    Example usage: multiple_rows = wait_for_multiple(By.XPATH, \"//a\")\n    \"\"\"\n    start_time = time.time()\n    old_elements = []\n    while start_time + max_wait_time > time.time():\n        new_elements = WebDriverWait(driver, 30).until(\n            EC.presence_of_all_elements_located((by, xpath))\n        ) # Raises Exception if none found. driver.find_elements() would return empty list instead.\n        if old_elements and len(old_elements) == len(new_elements):\n            return new_elements\n        old_elements = new_elements\n        time.sleep(interval_sleep) # The longer, the better if site is slower\n    raise Exception(\"More web elements are still loading\")",
                    "Class" : "language-python"
                }
            ]
        },
        {
            "Subtitle" : "Wait for text of element to be certain thing",
            "Intro" : "Even though a web element is found",
            "Cheats" : [
                {
                    "Explanation" : "",
                    "Cheat" : "# Wait that link contains \"Git\":\ngit_text_in_element = WebDriverWait(driver, 30).until(\n    EC.text_to_be_present_in_element((By.XPATH, \"//a\"), \"Git\")\n)",
                    "Class" : "language-python"
                }
            ]
        },
        {
            "Subtitle" : "Refresh()",
            "Intro" : "",
            "Cheats" : [
                {
                    "Explanation" : "When the page is refreshed, ensure the previous element is stale/non-existent before continuing",
                    "Cheat" : "# Find one element before refresh.\nelement = WebDriverWait(driver, 30).until(\n    EC.visibility_of_element_located((By.XPATH, \"//a\"))\n)\ndriver.refresh()\n# The site is refreshed after the previously located element becomes stale\nassert WebDriverWait(driver, 30).until(\n    EC.staleness_of(element)\n) == True",
                    "Class" : "language-python"
                }
            ]
        }
        
    ]
}
